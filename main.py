# This script will mass download soundtracks of an album from downloads.khinsider.com
import os.path
from os import mkdir
from pathlib import Path
from urllib.parse import unquote

import requests
from bs4 import BeautifulSoup
from tqdm import tqdm


def get_input(prompt, default=None):
    """
    Get user input with a default value if none is provided.
    :param prompt:
    :param default:
    :return:
    """
    return input(prompt) or default


def display_album(title: str, total_duration: str, audios: dict):
    """
    Display album information in the terminal
    :param title:
    :param total_duration:
    :param audios:
    :return:
    """
    print('\nALBUM')
    print(f'Title: {title}')
    print(f'Total Duration: {total_duration}')
    print('Available format:')
    for format_, space in audios.items():
        print(f'âœ“ {format_} ({space})')


def mb_to_gb(megabytes):
    return round(megabytes / 1000, 2)



def get_album_info(url):
    """
    Extracts album information from a Khinsider album page URL.

    Args:
        url (str): The URL of the Khinsider album page.

    Returns:
        tuple: A tuple containing the available audio formats (list of str),
               the total time of the soundtrack (str), and the space requirements
               for each audio format (list of str).
    """

    # Make a request to the album page URL and parse the HTML with BeautifulSoup
    html = requests.get(url)
    album_page = BeautifulSoup(html.text, 'html.parser')

    # Get the album title.
    album_title = album_page.find("h2").text

    # Get the soundtracks table.
    tables = album_page.find_all("table")
    soundtracks_table = tables[1]

    # Extract information about the soundtracks.
    ths = soundtracks_table.find_all("th")
    mp3_index = next(i for i, th in enumerate(ths) if th.text == "MP3")
    audio_formats = []
    for i in range(mp3_index, len(ths)):
        if audio_format := ths[i].text.strip():  # If str is not empty (truthy), it means an audio format is listed here
            audio_formats.append(audio_format)
        else:
            break

    duration, *spaces = ths[-(len(audio_formats) + 2):-1]
    duration = duration.text
    spaces = list(map(lambda s: f"{mb_to_gb(int((s.text.split(' ')[0]).replace(',', '')))} GB", spaces))

    # Create dictionary containing formats and its corresponding size
    audios = dict(zip(audio_formats, spaces))

    # Get all urls to soundtrack source page
    tds = soundtracks_table.find_all_next('td', class_='clickable-row')[::4]  # [::4] to avoid repetition of same URL
    soundtracks_page_url = list(map(lambda td: f"https://downloads.khinsider.com{td.next_element['href']}", tds))

    return album_title, duration, audios, soundtracks_page_url


def choose_audio_format(audios: dict, prompt='Choose a format:'):
    """
    Generate index for audio format and prompt the user to choose an audio format by typing the index.
    :param audios:
    :param prompt:
    :return:
    """
    print(prompt)
    for i, audio in enumerate(audios.items()):
        print(f'{i} - {audio[0]}')
    return get_input('', default=0)


def prepare_download_directory(dir_path):
    """
    Create new directory if the directory doesn't exist.
    :param dir_path:
    :return:
    """
    try:
        mkdir(dir_path)
    except FileExistsError as error:
        pass


def download_soundtracks(soundtracks_page_url, audio_format, dir_out):
    """
    Downloads the soundtracks of specified format to the specified output directory.
    :param soundtracks_page_url:
    :param audio_format:
    :param dir_out:
    :return:
    """
    print(f'{len(soundtracks_page_url)} files will be downloaded...')
    downloaded = 0
    for url in soundtracks_page_url:
        # Open source page
        html = requests.get(url)
        soundtrack_page = BeautifulSoup(html.text, 'html.parser')

        # Scrape the link to download resource
        source = soundtrack_page.find_all(class_='songDownloadLink')[audio_format].parent['href']

        # The website's url already formatted some characters to their corresponding code (%XX)
        # Unquote will reformat it from code back to its original character
        # Refer https://docs.python.org/3.10/library/urllib.parse.html#urllib.parse.unquote
        source = unquote(source)
        source = source.replace('#', '%23')  # The '#' character is bugged when URL encoded, this fixes it!

        filename = source.rsplit('/', 1)[1]
        filepath = f'{dir_out}/{filename}'

        # Checks if file already exists
        if os.path.isfile(filepath):
            print(f'Skipping {filename}, it already exists...')
            continue

        print(f'Downloading {filename}...')
        # Code and comment generated by ChatGPT-3
        # Make a GET request to the URL, but don't download the entire response at once
        response = requests.get(source, stream=True)

        total_size_in_bytes = int(response.headers.get('content-length', 0))
        block_size = 1024  # 1 Kilobyte

        progress_bar = tqdm(total=total_size_in_bytes, unit='iB', unit_scale=True)

        # Open a file to write the downloaded data to
        with open(filepath, 'wb') as file:
            for data in response.iter_content(block_size):
                progress_bar.update(len(data))
                file.write(data)

        progress_bar.close()

        downloaded += 1
    print(f'Downloads complete! {downloaded} files have been downloaded')


# URL to the album's page
album_url = str(get_input("Link to the album's page (from downloads.khinsider.com):\n"))

# Get soundtrack information
album_title, duration, audios, soundtracks_page_url = get_album_info(album_url)

# Display the information
display_album(album_title, duration, audios)

# Choose an audio format if there are more than one format available
audio_format = int(choose_audio_format(audios, '\nChoose a format:') if len(audios) > 1 else 0)

# Preset the output directory of audio file
dir_out = f'{str(Path.home())}/Music/{album_title}'
dir_out = str(get_input(f'\nDownload location (Press Enter to use default: {dir_out} ):\n', default=dir_out))
prepare_download_directory(dir_out)

print('\nPreparing download...')
download_soundtracks(soundtracks_page_url, audio_format, dir_out)
